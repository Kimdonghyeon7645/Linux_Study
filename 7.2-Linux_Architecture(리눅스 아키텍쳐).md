# 7월 2일 / Linux Architecture

### 리눅스 아키텍쳐(Linux Architecture)는,  
리눅스의 전반적인 구조를 담고 있는데, 여기서는 리눅스에서 애플리케이션이 어떻게 하드웨어들을 동작시키는 지의 과정에 거치는 리눅스 커널의 구조를 볼 수 있다.  
이 아키텍쳐는 안드로이드 아키텍쳐로 검색해서도 볼 수 있는데, 어플리케이션에서 단계의 차이는 있어도, 커널의 구조는 동일한 것을 알 수 있다.

![36ca6706-91c9-49c9-a849-cb981d09149f](https://user-images.githubusercontent.com/48408417/86352352-a0653d00-bca0-11ea-8965-d382c0d0a959.png)

user space(유저 영역)에서 애플리케이션이 실행되면, (몇몇 애플리케이션은 시스템 라이브러리를 이용하기도 해서,)  
소프트웨어에서가 아닌, 하드웨어 I/O(입출력)의 자원 요청이 필요하면, 

소프트웨어 인터럽트(software interrupt, 하드웨어를 부르는 것)가 실행되고,  
그 인터럽트는 시스템 콜(system call, 하드웨어를 찾도록 명령하는 것)으로 넘어가게 된다.

그러면 시스템 콜에서 가상 파일 시스템(Virtual file system)으로 넘어가는데,  
가상 파일 시스템은 간단하게 클래스안의 추상 메서드같이, open(), read(), exit()같은 함수를 가상 파일 시스템에서 부르며,  

그러면 실제 파일 시스템에서 가상 파일 시스템에서 부른 함수를 실행하게 된다.

파일 시스템은 파일과 그안의 자료를 저장하고 찾기쉽게 유지하고 관리하며,  
파일 시스템이라하면 이런 유지, 관리 방법을 말하게 된다.

이 파일 시스템은 여기선 일반 파일 시스템(general file system), 디바이스 파일 시스템(device file system), 네트워크 파일 시스템(network file system)으로 나뉘며, 

그 중 일반 파일 시스템은 버퍼 캐쉬(buffer cache)를 가지며, 네트워크 파일 시스템은 네트워크 서브시스템(network subsystem)을 가진다.  
여기서 네트워크 서브 시스템이라 하면, TCP나 IP 프로토콜의 stack(스텍)을 말한다.

이렇게 파일 시스템을 통했으면, 디바이스의 인터페이스(Device Interface)에서,  
결국 하드웨어, 디바이스 들을 접근할 수 있게 된다.

